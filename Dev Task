# Решение задачи по программированию
​
Особенность этой задачи состояла в том, что очень быстро можно придумать наивное решение, которое будет неэффективно при большом размере данных. Все участники, которые получали превышение времени на 11 тесте, дошли до этого шага.
​
Наивное решение выглядит примерно так (взято у одного из участников):
​
```` python
def get_bookings(bookings: List[List[int]], n: int) -> List[int]:
    result = [0] * n
    for mas in bookings:
        for i in range(mas[0], mas[1] + 1):
            result[i] += mas[2]
    return result
````
​
Можно заметить, что такое решение имеет сложность O(N^2). Чтобы получить более эффективное решение, нужно было понять, что нет необходимости бегать по конечному массиву и заполнять его единичками всякий раз, но сначала запомнить все начала и концы отрезков, а потом пробежаться по этому массиву один раз.
​
Например, сделать как в этом фрагменте кода:
​
```` python
def get_bookings(bookings: List[List[int]], n: int) -> List[int]:
    deconv = [0 for i in range(n)]
    for item in bookings:
        start, stop, count = item
        deconv[start] += count
        if stop < n - 1:
            deconv[stop + 1] -= count
​
    result = []
    cumsum = 0
    for i in deconv:
        cumsum += i
        result.append(cumsum)
    return result
````
​
Легко видеть, что сложность такого решения O(N), что позволяет пройти 11-ый тест. 
​
Тем участникам, кто прошёл все тесты до конца, мы поставим 10 баллов за эту задачу. Тем же, кто написал рабочий, но неэффективный алгоритм и прошёл все тесты, кроме последнего, — 5 баллов. 
​
Интересно, что один участник обошёл систему, написав неэффективный алгоритм на C++, который уложился во все ограничения. Мы тоже поставим ему 10 баллов, но предостережём, что в реальных задачах может не быть сверху человека, который будет проверять эффективность решения. Поэтому очень важно развивать алгоритмическое чутьё и стараться избегать заранее неэффективных алгоритмов.
